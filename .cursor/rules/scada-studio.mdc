---
alwaysApply: true
---

# SCADA Studio 开发规范

您是一位经验丰富的 TypeScript 程序员，熟悉 NestJS 框架，偏好清洁编程和设计模式。

生成的代码、修正和重构应遵循基本原则和命名规范。

## TypeScript 通用规范

### 基本原则

- 所有代码和文档使用中文注释。
- 始终声明每个变量和函数的类型（参数和返回值）。
  - 避免使用 any。
  - 创建必要的类型。
- 使用 JSDoc 记录公共类和方法。
- 函数内不留空行。
- 每个文件一个导出。

### 命名规范

- 类使用 PascalCase。
- 变量、函数和方法使用 camelCase。
- 文件和目录使用 kebab-case。
- 环境变量使用 UPPERCASE。
  - 避免魔法数字，定义常量。
- 每个函数以动词开头。
- 布尔变量使用动词。例如：isLoading、hasError、canDelete 等。
- 使用完整单词而不是缩写，拼写正确。
  - 标准缩写除外，如 API、URL 等。
  - 众所周知的缩写除外：
    - i, j 用于循环
    - err 用于错误
    - ctx 用于上下文
    - req, res, next 用于中间件函数参数

### 函数

- 在此上下文中，函数的概念也适用于方法。
- 编写短函数，单一目的。少于 20 条指令。
- 函数命名使用动词加其他内容。
  - 如果返回布尔值，使用 isX 或 hasX、canX 等。
  - 如果不返回任何内容，使用 executeX 或 saveX 等。
- 通过以下方式避免嵌套块：
  - 早期检查和返回。
  - 提取到工具函数。
- 使用高阶函数（map、filter、reduce 等）避免函数嵌套。
  - 简单函数使用箭头函数（少于 3 条指令）。
  - 非简单函数使用命名函数。
- 使用默认参数值而不是检查 null 或 undefined。
- 使用 RO-RO 减少函数参数
  - 使用对象传递多个参数。
  - 使用对象返回结果。
  - 声明输入参数和输出的必要类型。
- 使用单一抽象级别。

### 数据

- 不要滥用原始类型，将数据封装在复合类型中。
- 避免在函数中进行数据验证，使用具有内部验证的类。
- 偏好数据不可变性。
  - 对不改变的数据使用 readonly。
  - 对不改变的字面量使用 as const。

### 类

- 遵循 SOLID 原则。
- 偏好组合而非继承。
- 声明接口定义契约。
- 编写小类，单一目的。
  - 少于 200 条指令。
  - 少于 10 个公共方法。
  - 少于 10 个属性。

### 异常

- 使用异常处理您不期望的错误。
- 如果捕获异常，应该是为了：
  - 修复预期问题。
  - 添加上下文。
  - 否则，使用全局处理器。

### 测试

- 遵循 Arrange-Act-Assert 约定进行测试。
- 清楚命名测试变量。
  - 遵循约定：inputX、mockX、actualX、expectedX 等。
- 为每个公共函数编写单元测试。
  - 使用测试替身模拟依赖。
    - 执行不昂贵的第三方依赖除外。
- 为每个模块编写验收测试。
  - 遵循 Given-When-Then 约定。

## NestJS 特定规范

### 基本原则

- 使用模块化架构
- 将 API 封装在模块中。
  - 每个主要域/路由一个模块。
  - 每个路由一个控制器。
    - 其他控制器用于次要路由。
  - 包含数据类型的 models 文件夹。
    - 使用 class-validator 验证输入的 DTO。
    - 为输出声明简单类型。
  - 包含业务逻辑和持久化的 services 模块。
    - 使用 TypeORM 进行数据持久化的实体。
    - 每个实体一个服务。
- 核心模块用于 nest 构件
  - 全局过滤器用于异常处理。
  - 全局中间件用于请求管理。
  - 守卫用于权限管理。
  - 拦截器用于请求管理。
- 共享模块用于模块间共享的服务。
  - 工具
  - 共享业务逻辑

### 微服务架构

- 使用 NestJS 微服务进行服务间通信
- 每个服务都是独立的应用程序
- 使用 TCP 传输进行服务间通信
- 使用共享库进行跨服务代码复用
- 使用 MessagePattern 装饰器处理微服务消息

### 数据库持久化

- 使用 TypeORM 进行数据持久化
- 实体使用 TypeORM 装饰器进行定义
- 使用 Repository 模式进行数据访问
- 配置全局数据库模块来避免循环依赖
- 使用 @Global() 装饰器创建全局共享数据库模块

### 国际化

- 使用 nestjs-i18n 进行国际化
- 创建 i18n-lib 共享库
- 在异常过滤器和响应工具中使用国际化
- 支持多语言消息翻译
- 使用 I18nService 进行消息翻译

### DTO 验证

- 使用 class-validator 进行 DTO 验证
- 在 shared-dto-lib 中定义共享的 DTO
- 使用 ValidationPipe 进行自动验证
- 为每个输入 DTO 定义完整的验证规则

### 权限控制

- 使用 Casbin 进行权限管理
- 实现基于角色的访问控制（RBAC）
- 使用 RequirePermissions 装饰器定义权限要求
- 使用 PermissionGuard 进行权限检查

### 测试

- 使用 Jest 框架进行测试。
- 为每个控制器和服务编写测试。
- 为每个 api 模块编写端到端测试。
- 使用 supertest 进行 HTTP 测试。
- 为微服务编写 MessagePattern 测试。

# SCADA Studio 开发规范

您是一位经验丰富的 TypeScript 程序员，熟悉 NestJS 框架，偏好清洁编程和设计模式。

生成的代码、修正和重构应遵循基本原则和命名规范。

## TypeScript 通用规范

### 基本原则

- 所有代码和文档使用中文注释。
- 始终声明每个变量和函数的类型（参数和返回值）。
  - 避免使用 any。
  - 创建必要的类型。
- 使用 JSDoc 记录公共类和方法。
- 函数内不留空行。
- 每个文件一个导出。

### 命名规范

- 类使用 PascalCase。
- 变量、函数和方法使用 camelCase。
- 文件和目录使用 kebab-case。
- 环境变量使用 UPPERCASE。
  - 避免魔法数字，定义常量。
- 每个函数以动词开头。
- 布尔变量使用动词。例如：isLoading、hasError、canDelete 等。
- 使用完整单词而不是缩写，拼写正确。
  - 标准缩写除外，如 API、URL 等。
  - 众所周知的缩写除外：
    - i, j 用于循环
    - err 用于错误
    - ctx 用于上下文
    - req, res, next 用于中间件函数参数

### 函数

- 在此上下文中，函数的概念也适用于方法。
- 编写短函数，单一目的。少于 20 条指令。
- 函数命名使用动词加其他内容。
  - 如果返回布尔值，使用 isX 或 hasX、canX 等。
  - 如果不返回任何内容，使用 executeX 或 saveX 等。
- 通过以下方式避免嵌套块：
  - 早期检查和返回。
  - 提取到工具函数。
- 使用高阶函数（map、filter、reduce 等）避免函数嵌套。
  - 简单函数使用箭头函数（少于 3 条指令）。
  - 非简单函数使用命名函数。
- 使用默认参数值而不是检查 null 或 undefined。
- 使用 RO-RO 减少函数参数
  - 使用对象传递多个参数。
  - 使用对象返回结果。
  - 声明输入参数和输出的必要类型。
- 使用单一抽象级别。

### 数据

- 不要滥用原始类型，将数据封装在复合类型中。
- 避免在函数中进行数据验证，使用具有内部验证的类。
- 偏好数据不可变性。
  - 对不改变的数据使用 readonly。
  - 对不改变的字面量使用 as const。

### 类

- 遵循 SOLID 原则。
- 偏好组合而非继承。
- 声明接口定义契约。
- 编写小类，单一目的。
  - 少于 200 条指令。
  - 少于 10 个公共方法。
  - 少于 10 个属性。

### 异常

- 使用异常处理您不期望的错误。
- 如果捕获异常，应该是为了：
  - 修复预期问题。
  - 添加上下文。
  - 否则，使用全局处理器。

### 测试

- 遵循 Arrange-Act-Assert 约定进行测试。
- 清楚命名测试变量。
  - 遵循约定：inputX、mockX、actualX、expectedX 等。
- 为每个公共函数编写单元测试。
  - 使用测试替身模拟依赖。
    - 执行不昂贵的第三方依赖除外。
- 为每个模块编写验收测试。
  - 遵循 Given-When-Then 约定。

## NestJS 特定规范

### 基本原则

- 使用模块化架构
- 将 API 封装在模块中。
  - 每个主要域/路由一个模块。
  - 每个路由一个控制器。
    - 其他控制器用于次要路由。
  - 包含数据类型的 models 文件夹。
    - 使用 class-validator 验证输入的 DTO。
    - 为输出声明简单类型。
  - 包含业务逻辑和持久化的 services 模块。
    - 使用 TypeORM 进行数据持久化的实体。
    - 每个实体一个服务。
- 核心模块用于 nest 构件
  - 全局过滤器用于异常处理。
  - 全局中间件用于请求管理。
  - 守卫用于权限管理。
  - 拦截器用于请求管理。
- 共享模块用于模块间共享的服务。
  - 工具
  - 共享业务逻辑

### 微服务架构

- 使用 NestJS 微服务进行服务间通信
- 每个服务都是独立的应用程序
- 使用 TCP 传输进行服务间通信
- 使用共享库进行跨服务代码复用
- 使用 MessagePattern 装饰器处理微服务消息

### 数据库持久化

- 使用 TypeORM 进行数据持久化
- 实体使用 TypeORM 装饰器进行定义
- 使用 Repository 模式进行数据访问
- 配置全局数据库模块来避免循环依赖
- 使用 @Global() 装饰器创建全局共享数据库模块

### 国际化

- 使用 nestjs-i18n 进行国际化
- 创建 i18n-lib 共享库
- 在异常过滤器和响应工具中使用国际化
- 支持多语言消息翻译
- 使用 I18nService 进行消息翻译

### DTO 验证

- 使用 class-validator 进行 DTO 验证
- 在 shared-dto-lib 中定义共享的 DTO
- 使用 ValidationPipe 进行自动验证
- 为每个输入 DTO 定义完整的验证规则

### 权限控制

- 使用 Casbin 进行权限管理
- 实现基于角色的访问控制（RBAC）
- 使用 RequirePermissions 装饰器定义权限要求
- 使用 PermissionGuard 进行权限检查

### 测试

- 使用 Jest 框架进行测试。
- 为每个控制器和服务编写测试。
- 为每个 api 模块编写端到端测试。
- 使用 supertest 进行 HTTP 测试。
- 为微服务编写 MessagePattern 测试。
